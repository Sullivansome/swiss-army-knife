// scripts/generate-registry.ts
import * as fs from "fs";
import * as path from "path";

const TOOLS_DIR = path.join(process.cwd(), "components/tools");
const GENERATED_DIR = path.join(process.cwd(), "lib/generated");
const LOCALES = ["en", "zh"];

type ToolMeta = {
  slug: string;
  category: string;
  tags?: string[];
  icon?: string;
  seo?: { keywords?: string[] };
};

type ToolTranslations = Record<string, Record<string, unknown>>;

function getToolFolders(): string[] {
  if (!fs.existsSync(TOOLS_DIR)) return [];
  return fs
    .readdirSync(TOOLS_DIR, { withFileTypes: true })
    .filter((d) => d.isDirectory())
    .map((d) => d.name);
}

function loadToolMeta(folder: string): ToolMeta | null {
  const metaPath = path.join(TOOLS_DIR, folder, "meta.ts");
  if (!fs.existsSync(metaPath)) return null;

  // Read and parse meta.ts (simple extraction)
  const content = fs.readFileSync(metaPath, "utf-8");

  // Extract slug
  const slugMatch = content.match(/slug:\s*["']([^"']+)["']/);
  const categoryMatch = content.match(/category:\s*["']([^"']+)["']/);

  if (!slugMatch || !categoryMatch) {
    console.warn(`Warning: Could not parse meta.ts for ${folder}`);
    return null;
  }

  const meta: ToolMeta = {
    slug: slugMatch[1],
    category: categoryMatch[1],
  };

  // Extract optional fields
  const tagsMatch = content.match(/tags:\s*\[([^\]]*)\]/);
  if (tagsMatch) {
    meta.tags = tagsMatch[1]
      .split(",")
      .map((t) => t.trim().replace(/["']/g, ""))
      .filter(Boolean);
  }

  const iconMatch = content.match(/icon:\s*["']([^"']+)["']/);
  if (iconMatch) {
    meta.icon = iconMatch[1];
  }

  const keywordsMatch = content.match(/keywords:\s*\[([^\]]*)\]/);
  if (keywordsMatch) {
    meta.seo = {
      keywords: keywordsMatch[1]
        .split(",")
        .map((k) => k.trim().replace(/["']/g, ""))
        .filter(Boolean),
    };
  }

  return meta;
}

function loadToolTranslations(folder: string): ToolTranslations {
  const translations: ToolTranslations = {};

  for (const locale of LOCALES) {
    const i18nPath = path.join(TOOLS_DIR, folder, "i18n", `${locale}.json`);
    if (fs.existsSync(i18nPath)) {
      try {
        translations[locale] = JSON.parse(fs.readFileSync(i18nPath, "utf-8"));
      } catch (e) {
        console.warn(`Warning: Could not parse ${i18nPath}`);
      }
    }
  }

  return translations;
}

function generateRegistry(): void {
  const folders = getToolFolders();
  const tools: Record<string, ToolMeta> = {};
  const allTranslations: Record<string, Record<string, unknown>> = {};

  // Initialize locale containers
  for (const locale of LOCALES) {
    allTranslations[locale] = {};
  }

  for (const folder of folders) {
    // Check if this is a new-style plugin (has meta.ts)
    const meta = loadToolMeta(folder);
    if (!meta) continue;

    tools[meta.slug] = meta;

    // Load translations
    const translations = loadToolTranslations(folder);
    for (const locale of LOCALES) {
      if (translations[locale]) {
        allTranslations[locale][meta.slug] = translations[locale];
      }
    }
  }

  // Ensure generated directory exists
  if (!fs.existsSync(GENERATED_DIR)) {
    fs.mkdirSync(GENERATED_DIR, { recursive: true });
  }

  // Generate tool-registry.ts
  const registryContent = `// Auto-generated by scripts/generate-registry.ts — do not edit manually
import type { ToolMeta } from "../tool-types";

export const toolRegistry: Record<string, ToolMeta> = ${JSON.stringify(tools, null, 2)};

// Dynamic loaders for each tool - returns the module with default export
export const toolLoaders = {
${Object.keys(tools)
  .map(
    (slug) =>
      `  "${slug}": () => import("../../components/tools/${slug}/index"),`,
  )
  .join("\n")}
} as const;

export const toolSlugs = Object.keys(toolRegistry);
`;

  fs.writeFileSync(
    path.join(GENERATED_DIR, "tool-registry.ts"),
    registryContent,
  );

  // Generate tool-i18n.ts
  const i18nContent = `// Auto-generated by scripts/generate-registry.ts — do not edit manually

const toolTranslations: Record<string, Record<string, unknown>> = ${JSON.stringify(allTranslations, null, 2)};

export function getToolLabels(slug: string, locale: string): Record<string, unknown> | null {
  return (toolTranslations[locale]?.[slug] ?? toolTranslations["en"]?.[slug] ?? null) as Record<string, unknown> | null;
}
`;

  fs.writeFileSync(path.join(GENERATED_DIR, "tool-i18n.ts"), i18nContent);

  console.log(`Generated registry with ${Object.keys(tools).length} tools`);
}

generateRegistry();
